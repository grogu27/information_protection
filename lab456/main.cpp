#include <iostream>
#include "src//crypto.hpp"

int main() {
    int choice;
    while (true) {
        std::cout << "\n=== Криптографическая библиотека ===\n";
        std::cout << "1. (Лаб.1) Быстрое возведение в степень\n";
        std::cout << "2. (Лаб.1) Тест Ферма\n";
        std::cout << "3. (Лаб.1) Расширенный Евклид\n";
        std::cout << "4. (Лаб.2) Дискретный логарифм (BSGS)\n";
        std::cout << "5. (Лаб.3) Diffie-Hellman\n";
        std::cout << "6. (Лаб.4) Шифр Шамира (аффинный)\n";
        std::cout << "7. (Лаб.5) Эль-Гамаль\n";
        std::cout << "8. (Лаб.6) RSA\n";
        std::cout << "0. Выход\n";
        std::cout << "Выбор: ";
        std::cin >> choice;

        if (choice == 0) break;

        if (choice == 1) {
            long long a, x, p;
            std::cout << "a x p: "; std::cin >> a >> x >> p;
            std::cout << "a^x mod p = " << mod_pow(a, x, p) << "\n";
        }
        else if (choice == 2) {
            long long n; int k;
            std::cout << "n k: "; std::cin >> n >> k;
            std::cout << n << (is_prime_fermat(n, k) ? " — вероятно простое\n" : " — составное\n");
        }
        else if (choice == 3) {
            long long a, b;
            std::cout << "a b: "; std::cin >> a >> b;
            auto [g, x, y] = extended_gcd2(a, b);
            std::cout << "gcd=" << g << ", x=" << x << ", y=" << y << "\n";
        }
        else if (choice == 4) {
            int mode; std::cout << "1. Вручную 2. Авто: "; std::cin >> mode;
            if (mode == 1) {
                long long a, y, p;
                std::cout << "a y p: "; std::cin >> a >> y >> p;
                long long x = baby_step_giant_step(a, y, p);
                std::cout << "x = " << (x == -1 ? "не найден" : std::to_string(x)) << "\n";
            } else {
                auto [a, y, p, x] = bsgs_with_random_params();
                if (a == -1) std::cout << "Ошибка генерации\n";
                else std::cout << "a=" << a << " y=" << y << " p=" << p << " x=" << x << "\n";
            }
        }
        else if (choice == 5) {
            int mode; std::cout << "1. Вручную 2. Авто: "; std::cin >> mode;
            if (mode == 1) diffie_hellman_manual();
            else diffie_hellman_auto();
        }
        else if (choice == 6) {
            // Подробное объяснение для Лабораторной №4
            std::cout << "\n--- Лабораторная №4: Аффинный шифр (\"Шамир\") ---\n";
            std::cout << "Описание: Аффинный шифр представляет собой отображение байта x в y = (C1 * x + C2) mod p.\n";
            std::cout << "Требования: p должно быть > 256 (чтобы результат помещался в байт), C1 должен быть обратим по модулю p (gcd(C1,p)=1).\n";
            std::cout << "Режимы работы: шифрование читает входной файл побайтово, преобразует каждый байт и записывает результат.\n";
            std::cout << "Расшифровка использует обратный множитель C1^{-1} по модулю p и обращает преобразование.\n";
            std::cout << "Формат работы: программа поддерживает ввод параметров пользователем и автоматическую генерацию параметров.\n";
            std::cout << "Ограничения: если p слишком мало (y > 255), операция прервётся и сообщит об ошибке — увеличьте p.\n\n";
            lab4_shamir();
        }
        else if (choice == 7) {
            // Подробное объяснение для Лабораторной №5
            std::cout << "\n--- Лабораторная №5: Эль-Гамаль ---\n";
            std::cout << "Описание: алгоритм основан на вычислениях в мультипликативной группе по модулю простого p.\n";
            std::cout << "Ключи: приватный ключ x, публичный y = g^x mod p, где g — примитивный корень по модулю p.\n";
            std::cout << "Шифрование: для каждого байта m выбирается случайное k, затем сохраняются пары (a = g^k mod p, b = m * y^k mod p) в бинарный файл.\n";
            std::cout << "Расшифровка: восстановление m = b * (a^x)^{-1} mod p.\n";
            std::cout << "Формат файла: каждая зашифрованная единица представлена двумя 8-байтовыми числами (a и b).\n";
            std::cout << "Режимы: ввод параметров вручную или автоматическая генерация p, g, x.\n\n";
            lab5_elgamal();
        }
        else if (choice == 8) {
            // Подробное объяснение для Лабораторной №6
            std::cout << "\n--- Лабораторная №6: RSA ---\n";
            std::cout << "Описание: классическая схема RSA. Пара простых p,q -> n = p*q, phi = (p-1)*(q-1).\n";
            std::cout << "Ключи: публичный экспонент e и приватный d такие, что e*d ≡ 1 (mod phi).\n";
            std::cout << "Шифрование: для каждого байта m (m < n) вычисляется c = m^e mod n и записывается как 8-байтовое целое.\n";
            std::cout << "Расшифровка: m = c^d mod n. Для корректной работы необходимо p и q такие, что n > 255 (иначе нельзя кодировать байт).\n";
            std::cout << "Режимы: ручной ввод p,q,d или автоматическая генерация p,q (вероятностно простые) и вычисление ключей.\n\n";
            lab6_rsa();
        }
        else std::cout << "Неверный выбор.\n";
    }
    return 0;
}
